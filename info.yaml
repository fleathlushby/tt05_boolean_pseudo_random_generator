--- 
# TinyTapeout project information
project:
  wokwi_id:    0        # If using wokwi, set this to your project's ID

# If using an HDL, set wokwi_id as 0 and uncomment and list your source files here. 
# Source files must be in ./src and you must list each source file separately
  source_files:        
    - tt_um_prg.v
    - prg.v
    - SELECT_NOT_8.v
    - MUX21I.v
    - GF_INV_8_shared.v
    - GF_MULS_4_shared.v
    - GF_SQ_SCL_4.v
    - GF_SQ_2.v
    - GF_SCLW_2.v
    - GF_INV_4_shared.v
  top_module:  "tt_um_prg"      # put the name of your top module here, make it unique by prepending your github username

# How many tiles your design occupies? A single tile is about 167x108 uM.
  tiles: "1x2"    # Valid values: 1x1, 1x2, 2x2, 4x2 or 8x2

# Keep a track of the submission yaml
yaml_version: 4

# As everyone will have access to all designs, try to make it easy for someone new to your design to know what
# it does and how to operate it. This info will be automatically collected and used to make a datasheet for the chip.
#
# Here is a great example: https://github.com/davidsiaw/tt02-davidsiaw-stackcalc/blob/38c5647f83aad2aec675d566aa3d67b98f0aac81/info.yaml
documentation: 
  author:       "SEAL, CSE Department, IIT Kharagpur"
  title:        "A Boolean function based pseudo random number generator (PRNG)"
  language:     "Verilog"
  description:  "Boolean function based pseudo random number generator implemented using finite field"

# Longer description of how the project works. You can use standard markdown format.
  how_it_works: |
      **Principle of operation of Boolean function based pseudo random number generator (PRNG)**   
      This implementation of a PRNG contains linear mappings to and from the following blocks:
      - one $GF(2^4)$ normal base,
      - three instances of $GF(2^4)$ multipliers,
      - one $GF(2^4)$ inverter, and
      - one square scaler.  
      The input and output strings of the PRNG are split into five and three shares, respectively. Our PRNG generates random values based on the five input bytes or variables. Instead of relying solely on a single seed or input, it takes several inputs thereby introducing more control over the randomness of the generated values. Thus, the multiple input bytes are used as seeds. The seeds are generated from external factors like time, user-provided data, and environmental conditions. Additionally, previous random values produced by our PRNG design can also be considered as a valid seed. This results in a more tailored or context-aware randomness, which finds its application in simulations, games, cryptography, or data generation. The operation of the Boolean function based PRNG can be classified into three phases, namely, Affine transformation ($1^{st}$ phase), Finite field inversion ($2^{nd}$ phase) and the combination of Finite field multiplication and inverse linear mapping ($3^{rd}$ phase) as evident from the block diagram 'pseudorandomgenerator.png'. The working procedure of these phases are discussed as follows:
      
      **First phase- Affine transformation**  
      In the first phase, three shares are processed by the linear input mapping and afterwards fed into a multiplier. Similarly, a uniform reduction to two shares is fed into the square scaler.  
      $$(a,b,c)\mapsto(a,b \oplus c)\ \ \ \ (1)$$
      The output of the multiplier is partially re-masked by 8 bits of randomness while the square scaler output is left as it is. We use fresh randomness at the end of the first phase to satisfy uniformity during the combination of the square scaler’s and the multiplier’s outputs. The result is saved in a register, $P_1$ as illustrated in the block diagram.
      
      **Second phase- Finite field inversion**  
      In the second phase, the overall five shares are combined into four shares. Due to the previous remasking, this can be done uniformly as such:
            
      $$(x,y,a,b,c)\mapsto(x,y \oplus (r_1 \oplus r_2),a \oplus (b \oplus r_1),c \oplus r_2)\ \ \ \ (2)$$
      
      In the above equation, $x,y$ denote the square scaler output, while $a,b,c$ denote the multiplier output. Note that a register needs to hold all five shares before recombination to prevent leakage. After recombination, the four shares are fed into the inverter and re-masked with 8 bits of randomness. A register stage named $P_2$, preventing glitches, follows this inverter. 
      
      **Third phase- Finite field multiplication and inverse linear mapping**  
      In the final stage, the re-masked outputs are reduced to three shares uniformly by the following function.
            
      $$(a,b,c,d)\mapsto(a \oplus (b \oplus r_3),c \oplus r_4,d \oplus r_3 \oplus r_4)\ \ \ \ (3)$$
            
      Subsequently, these shares are fed into two multipliers. Finally, the inverse linear mapping follows. With this construction, it is enough to have three input shares to the generator since the multiplier block requires only three shares. At this stage, we again add a randomness after the inverter to break the dependency between the inputs of the multipliers in the third phase.  
      In general, we need to reduce the number of shares from five to four at the end of the first phase as the inverter in the second phase can process four input strings. Moreover, the multipliers in the final stage is capable of processing three shares of input thus enforcing the reduction of shares from four to three at the end of the second phase.  
    



      
# Instructions on how someone could test your project, include things like what buttons do what and how to set the clock if needed
  how_to_test:  |
      After reset, the ena signal is set to logic '1'. This enables the device to load input values in multiple shares. After loading all the input shares, the ena signal is reset.
      After two clock cycles, the output ready (uio_out) is set to logic '1' and the multiple output shares are generated.

# A description of what the inputs do (e.g. red button, SPI CLK, SPI MOSI, etc).
  inputs:               
    - input bit 
    - input bit 
    - input bit 
    - input bit 
    - input bit 
    - input bit 
    - input bit 
    - input bit 
# A description of what the outputs do (e.g. status LED, SPI MISO, etc)
  outputs:
    - output bit 
    - output bit 
    - output bit 
    - output bit
    - output bit
    - output bit
    - output bit
    - output bit
# A description of what the bidirectional I/O pins do (e.g. I2C SDA, I2C SCL, etc)
  bidirectional:
    - output ready
    - none
    - none
    - none
    - none
    - none
    - none
    - none

# The following fields are optional
  tag:          "test, encryption"      # comma separated list of tags: test, encryption, experiment, clock, animation, utility, industrial, pwm, fpga, alu, microprocessor, risc, riscv, sensor, signal generator, fft, filter, music, bcd, sound, serial, timer, random number generator, calculator, decoder, counter, puzzle, multiplier, game, oscillator,
  external_hw:  ""      # Describe any external hardware needed
  discord:      "fleathlushby"      # Your discord handle, used for communication and automatically assigning tapeout role after a submission
  doc_link:     ""      # URL to longer form documentation, eg the README.md in your repository
  clock_hz:     10000000       # Clock frequency in Hz (if required)
  picture:      "pseudorandomgenerator.png"      # relative path to a picture in your repository
